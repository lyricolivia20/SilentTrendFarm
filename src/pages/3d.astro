---
import Layout from '../layouts/Layout.astro';
import { SEO } from 'astro-seo';

const seoConfig = {
	title: "AI 3D Generator — Text to Image to 3D | LyriCodes",
	description: "Transform text prompts into 3D models using AI. Generate images with SDXL and convert them to 3D models with TripoSR. Free, browser-based 3D creation tool.",
	openGraph: {
		basic: {
			title: "AI 3D Generator — Create 3D Models from Text",
			type: "website",
			image: "/og-3d-generator.svg",
		},
		optional: {
			description: "Transform text prompts into 3D models using AI. Generate images with SDXL and convert them to 3D models with TripoSR.",
			siteName: "LyriCodes",
		},
	},
	twitter: {
		card: "summary_large_image",
		title: "AI 3D Generator — Create 3D Models from Text",
		description: "Transform text prompts into 3D models using AI. Free, browser-based 3D creation tool.",
		image: "/og-3d-generator.png",
	},
	extend: {
		meta: [
			{ name: "keywords", content: "AI 3D generator, text to 3D, image to 3D, SDXL, TripoSR, 3D model generator, AI art, WebGL, Three.js" },
			{ name: "application-name", content: "LyriCodes 3D Generator" },
			{ property: "og:video:type", content: "text/html" },
		],
		link: [
			{ rel: "preload", href: "/js/three.js", as: "script" },
			{ rel: "preload", href: "/js/GLTFLoader.js", as: "script" },
		],
	},
};
---

<Layout title={seoConfig.title} description={seoConfig.description} image="/og-3d-generator.svg">
	<div class="relative -mx-6 -mt-12 -mb-12">
		<!-- 3D Canvas Container -->
		<div id="canvas-container" class="w-full h-screen relative">
			<!-- Loading state -->
			<div id="loading" class="absolute inset-0 flex items-center justify-center bg-zinc-950 z-10">
				<div class="text-center">
					<div class="w-12 h-12 border-2 border-emerald-500/30 border-t-emerald-500 rounded-full animate-spin mx-auto mb-4"></div>
					<p class="text-zinc-500 font-mono text-sm">Initializing 3D environment...</p>
				</div>
			</div>
			
			<!-- UI Overlay -->
			<div id="ui-overlay" class="absolute inset-0 pointer-events-none z-20 opacity-0 transition-opacity duration-500">
				<!-- Title -->
				<div class="absolute top-8 left-8 right-8 pointer-events-auto">
					<h1 class="text-3xl font-bold text-zinc-100 font-display mb-2">AI Pipeline: Text → Image → 3D</h1>
					<p class="text-zinc-500 font-mono text-sm">// Generative AI Model Pipeline with Hugging Face Spaces</p>
				</div>
				
				<!-- Pipeline Container -->
				<div class="absolute bottom-8 left-8 right-8 pointer-events-auto">
					<div class="glass-panel p-6 rounded-xl">
						<!-- Pipeline Steps -->
						<div class="flex items-center justify-between gap-4">
							<!-- Step 1: Text Input -->
							<div class="flex-1">
								<div class="mb-2">
									<span class="text-emerald-400 font-mono text-xs">STEP 1: TEXT</span>
								</div>
								<input 
									type="text" 
									id="prompt-input" 
									placeholder="Enter your prompt..."
									class="w-full bg-zinc-900/50 border border-zinc-700 rounded-lg px-3 py-2 text-sm text-zinc-100 placeholder-zinc-500 focus:outline-none focus:border-emerald-500"
								/>
								<button id="btn-generate" class="mt-2 w-full bg-emerald-500/20 hover:bg-emerald-500/30 border border-emerald-500/50 text-emerald-400 px-3 py-2 rounded-lg text-xs font-mono transition-colors">
									Start Pipeline →
								</button>
							</div>
							
							<!-- Arrow 1 -->
							<div id="arrow-1" class="flex items-center opacity-30 transition-opacity duration-500 shrink-0">
								<svg class="w-6 h-6 text-zinc-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
								</svg>
							</div>
							
							<!-- Step 2: Image Generation -->
							<div class="flex-1 min-w-0">
								<div class="mb-2">
									<span class="text-cyan-400 font-mono text-xs">STEP 2: IMAGE</span>
								</div>
								<div id="image-container" class="w-full h-24 bg-zinc-900/50 border border-zinc-700 rounded-lg flex items-center justify-center relative overflow-hidden">
									<span id="image-placeholder" class="text-zinc-600 text-xs font-mono">Awaiting generation...</span>
									<img id="generated-image" class="w-full h-full object-cover absolute inset-0 hidden" />
								</div>
							</div>
							
							<!-- Arrow 2 -->
							<div id="arrow-2" class="flex items-center opacity-30 transition-opacity duration-500 shrink-0">
								<svg class="w-6 h-6 text-zinc-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
								</svg>
							</div>
							
							<!-- Step 3: 3D Model -->
							<div class="flex-1 min-w-0">
								<div class="mb-2">
									<span class="text-violet-400 font-mono text-xs">STEP 3: 3D MODEL</span>
								</div>
								<div class="w-full h-24 bg-zinc-900/50 border border-zinc-700 rounded-lg flex items-center justify-center">
									<span id="model-status" class="text-zinc-600 text-xs font-mono text-center px-2">Awaiting conversion...</span>
								</div>
								<div class="flex gap-1 mt-2">
									<button id="btn-generate-3d" class="flex-1 bg-violet-500/20 hover:bg-violet-500/30 border border-violet-500/50 text-violet-400 px-2 py-1.5 rounded-lg text-xs font-mono transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
										Generate 3D
									</button>
									<button id="btn-demo" class="flex-1 bg-zinc-700/50 hover:bg-zinc-700/70 border border-zinc-600 text-zinc-400 px-2 py-1.5 rounded-lg text-xs font-mono transition-colors">
										Demo
									</button>
								</div>
							</div>
						</div>
					</div>
				</div>
				
				<!-- Status -->
				<div id="generation-status" class="absolute top-24 left-1/2 transform -translate-x-1/2 pointer-events-auto hidden">
					<div class="glass-panel p-3 rounded-lg">
						<div class="flex items-center gap-2 text-xs font-mono text-zinc-400">
							<div class="w-3 h-3 border border-emerald-500/50 border-t-emerald-500 rounded-full animate-spin"></div>
							<span id="status-text">Processing...</span>
						</div>
					</div>
				</div>
				
				<!-- Controls hint -->
				<div class="absolute top-8 right-8 pointer-events-auto">
					<div class="glass-panel p-3 rounded-lg">
						<div class="space-y-1 text-zinc-500 text-xs font-mono">
							<p><span class="text-zinc-400">Drag</span> — Rotate</p>
							<p><span class="text-zinc-400">Scroll</span> — Zoom</p>
							<p><span class="text-zinc-400">Double-click</span> — Reset</p>
						</div>
					</div>
				</div>
				
				<!-- Model Info panel -->
				<div id="model-info" class="absolute top-32 right-8 pointer-events-auto hidden">
					<div class="glass-panel p-4 rounded-xl">
						<p class="text-zinc-400 font-mono text-xs mb-2">Model Stats</p>
						<div class="space-y-1 text-xs font-mono">
							<p class="text-zinc-500">Vertices: <span id="vertex-count" class="text-emerald-400">0</span></p>
							<p class="text-zinc-500">Triangles: <span id="triangle-count" class="text-cyan-400">0</span></p>
							<p class="text-zinc-500">Materials: <span id="material-count" class="text-violet-400">0</span></p>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	
	<style>
		.glass-panel {
			background: rgba(24, 24, 27, 0.8);
			backdrop-filter: blur(12px);
			-webkit-backdrop-filter: blur(12px);
			border: 1px solid rgba(63, 63, 70, 0.5);
		}
		
		@keyframes pulse-glow {
			0%, 100% { opacity: 0.3; }
			50% { opacity: 1; }
		}
		
		.arrow-active {
			animation: pulse-glow 2s ease-in-out infinite;
		}
	</style>
	
	<!-- JSON-LD Structured Data for SEO -->
	<script type="application/ld+json" set:html={JSON.stringify({
		"@context": "https://schema.org",
		"@type": "WebApplication",
		"name": "LyriCodes AI 3D Generator",
		"description": "Transform text prompts into 3D models using AI. Generate images with SDXL and convert them to 3D models with TripoSR.",
		"url": "https://lyricodes.dev/3d",
		"applicationCategory": "DesignApplication",
		"operatingSystem": "Web Browser",
		"offers": {
			"@type": "Offer",
			"price": "0",
			"priceCurrency": "USD"
		},
		"featureList": [
			"Text to Image generation with SDXL",
			"Image to 3D conversion with TripoSR",
			"Real-time 3D model preview",
			"GLB model export"
		],
		"creator": {
			"@type": "Organization",
			"name": "LyriCodes",
			"url": "https://lyricodes.dev"
		}
	})} />
	
	<script is:inline src="/js/three.js"></script>
	<script is:inline src="/js/OrbitControls.js"></script>
	<script is:inline src="/js/GLTFLoader.js"></script>
		
		<script is:inline>
		// Initialize 3D scene
		function init() {
			if (typeof THREE === 'undefined') {
				console.error('THREE.js not loaded');
				return;
			}
			const container = document.getElementById('canvas-container');
			const loading = document.getElementById('loading');
			const uiOverlay = document.getElementById('ui-overlay');
			const vertexCountEl = document.getElementById('vertex-count');
			const triangleCountEl = document.getElementById('triangle-count');
			const materialCountEl = document.getElementById('material-count');
			
			// Scene setup - Minimalist white room as default
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);
			scene.fog = new THREE.Fog(0xffffff, 10, 50);
			
			// Camera
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 5, 15);
			camera.lookAt(0, 0, 0);
			
			// Renderer
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			container.appendChild(renderer.domElement);
			
			// Controls
			const controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.minDistance = 5;
			controls.maxDistance = 50;
			controls.maxPolarAngle = Math.PI / 2 + 0.1;
			controls.target.set(0, 2, 0);
			
			// Lights - Clean white room lighting by default
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
			scene.add(ambientLight);
			
			const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
			mainLight.position.set(10, 20, 10);
			mainLight.castShadow = true;
			mainLight.shadow.mapSize.width = 2048;
			mainLight.shadow.mapSize.height = 2048;
			scene.add(mainLight);
			
			// Dynamic lights that will be updated based on theme
			const dynamicLights = [];
			const pointLight1 = new THREE.PointLight(0xffffff, 0, 20);
			pointLight1.position.set(-5, 3, 5);
			scene.add(pointLight1);
			dynamicLights.push(pointLight1);
			
			const pointLight2 = new THREE.PointLight(0xffffff, 0, 20);
			pointLight2.position.set(5, 3, -5);
			scene.add(pointLight2);
			dynamicLights.push(pointLight2);
			
			const pointLight3 = new THREE.PointLight(0xffffff, 0, 20);
			pointLight3.position.set(0, 5, 0);
			scene.add(pointLight3);
			dynamicLights.push(pointLight3);
			
			// Ground plane with grid - White minimalist by default
			const groundGeometry = new THREE.PlaneGeometry(100, 100);
			const groundMaterial = new THREE.MeshStandardMaterial({ 
				color: 0xf0f0f0,
				roughness: 0.9,
				metalness: 0.1
			});
			const ground = new THREE.Mesh(groundGeometry, groundMaterial);
			ground.rotation.x = -Math.PI / 2;
			ground.receiveShadow = true;
			scene.add(ground);
			
			// Grid helper
			const gridHelper = new THREE.GridHelper(100, 100, 0xcccccc, 0xcccccc);
			gridHelper.position.y = 0.01;
			scene.add(gridHelper);
			
			// Model container group
			const modelGroup = new THREE.Group();
			scene.add(modelGroup);
			
			// GLB Loader for models
			const gltfLoader = new THREE.GLTFLoader();
			let currentModel = null;
			
			// UI Elements
			const promptInput = document.getElementById('prompt-input');
			const btnGenerate = document.getElementById('btn-generate');
			const btnDemo = document.getElementById('btn-demo');
			const modelInfo = document.getElementById('model-info');
			const generationStatus = document.getElementById('generation-status');
			const statusText = document.getElementById('status-text');
			const generatedImage = document.getElementById('generated-image');
			const imagePlaceholder = document.getElementById('image-placeholder');
			const imageContainer = document.getElementById('image-container');
			const modelStatus = document.getElementById('model-status');
			const arrow1 = document.getElementById('arrow-1');
			const arrow2 = document.getElementById('arrow-2');
			const btnGenerate3d = document.getElementById('btn-generate-3d');
			
			// Backend API URL (change for production)
			const API_BASE = 'http://localhost:8000';
			
			// Function to update environment based on theme
			function updateEnvironment(themeParams) {
				if (!themeParams) return;
				
				// Update background color
				if (themeParams.skybox_color) {
					scene.background = new THREE.Color(themeParams.skybox_color);
				}
				
				// Update fog
				if (themeParams.fog_color && themeParams.fog_density) {
					scene.fog = new THREE.FogExp2(themeParams.fog_color, themeParams.fog_density);
				}
				
				// Update ground color
				if (themeParams.ground_color) {
					groundMaterial.color = new THREE.Color(themeParams.ground_color);
				}
				
				// Update grid color
				if (themeParams.grid_color) {
					scene.remove(gridHelper);
					const newGrid = new THREE.GridHelper(100, 100, themeParams.grid_color, themeParams.grid_color);
					newGrid.position.y = 0.01;
					scene.add(newGrid);
				}
				
				// Update lights
				if (themeParams.lights && Array.isArray(themeParams.lights)) {
					themeParams.lights.forEach((lightConfig, index) => {
						if (lightConfig.type === 'ambient') {
							ambientLight.color = new THREE.Color(lightConfig.color);
							ambientLight.intensity = lightConfig.intensity;
						} else if (lightConfig.type === 'directional') {
							mainLight.color = new THREE.Color(lightConfig.color);
							mainLight.intensity = lightConfig.intensity;
						} else if (lightConfig.type === 'point' && dynamicLights[index]) {
							dynamicLights[index].color = new THREE.Color(lightConfig.color);
							dynamicLights[index].intensity = lightConfig.intensity;
							if (lightConfig.position) {
								dynamicLights[index].position.set(...lightConfig.position);
							}
						}
					});
				}
			}
			
			// Pipeline state
			let pipelineStage = 0; // 0: idle, 1: generating image, 2: image ready, 3: 3d generated
			let currentImageUrl = null;
			
			function showStatus(text) {
				statusText.textContent = text;
				generationStatus.classList.remove('hidden');
			}
			
			function hideStatus() {
				generationStatus.classList.add('hidden');
			}
			
			// Update pipeline visual state
			function updatePipelineState(stage) {
				pipelineStage = stage;
				
				// Update arrows
				const arrows = [arrow1, arrow2];
				arrows.forEach((arrow, i) => {
					if (stage >= i + 1) {
						arrow?.classList.remove('opacity-30');
						arrow?.classList.add('opacity-100', 'arrow-active');
					} else {
						arrow?.classList.add('opacity-30');
						arrow?.classList.remove('opacity-100', 'arrow-active');
					}
				});
				
				// Update button states
				if (btnGenerate3d) {
					btnGenerate3d.disabled = stage < 2;
				}
				
				// Update status texts
				if (stage === 2) {
					modelStatus.textContent = 'Ready for 3D conversion';
					modelStatus.classList.remove('text-zinc-600');
					modelStatus.classList.add('text-violet-400');
				} else if (stage === 3) {
					modelStatus.textContent = '3D Model loaded!';
					modelStatus.classList.remove('text-zinc-600');
					modelStatus.classList.add('text-violet-400');
				} else {
					modelStatus.textContent = 'Awaiting conversion...';
					modelStatus.classList.add('text-zinc-600');
					modelStatus.classList.remove('text-violet-400');
				}
			}
			
			// Text-to-Image using SDXL via backend
			async function generateImage(prompt) {
				try {
					const response = await fetch(`${API_BASE}/api/generate-image`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							prompt: prompt,
							enhance_prompt: true,
							generate_t_pose: true,
							analyze_theme: true
						})
					});
					
					if (!response.ok) {
						const error = await response.json();
						throw new Error(error.detail || 'Image generation failed');
					}
					
					const data = await response.json();
					
					// Update environment based on theme analysis
					if (data.theme_analysis && data.theme_analysis.environment_params) {
						updateEnvironment(data.theme_analysis.environment_params);
					}
					
					return {
						imageUrl: `data:image/png;base64,${data.image_base64}`,
						enhancedPrompt: data.enhanced_prompt,
						theme: data.theme_analysis
					};
				} catch (error) {
					console.error('SDXL generation error:', error);
					// Fallback to Pollinations
					const encodedPrompt = encodeURIComponent(prompt + ', T-pose, full body character, white background');
					const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=512&height=512&nologo=true`;
					
					return new Promise((resolve, reject) => {
						const img = new Image();
						img.crossOrigin = 'anonymous';
						img.onload = () => resolve({ imageUrl, fallback: true });
						img.onerror = () => reject(new Error('Image generation failed'));
						img.src = imageUrl;
					});
				}
			}
			
			// Image to 3D using Hugging Face Spaces (TripoSR) via backend
			async function generateModel3D(imageUrl) {
				try {
					const response = await fetch(`${API_BASE}/api/image-to-3d`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ image_url: imageUrl })
					});
					
					if (!response.ok) {
						const error = await response.json();
						throw new Error(error.detail || '3D generation failed');
					}
					
					const data = await response.json();
					// Convert base64 GLB to blob URL
					const glbBytes = atob(data.glb_base64);
					const glbArray = new Uint8Array(glbBytes.length);
					for (let i = 0; i < glbBytes.length; i++) {
						glbArray[i] = glbBytes.charCodeAt(i);
					}
					const blob = new Blob([glbArray], { type: 'model/gltf-binary' });
					return URL.createObjectURL(blob);
				} catch (error) {
					console.error('3D generation error:', error);
					throw error;
				}
			}
			
			// Load GLB model
			function loadModel(url) {
				// Remove previous model
				if (currentModel) {
					modelGroup.remove(currentModel);
					currentModel = null;
				}
				
				showStatus('Loading 3D model...');
				
				gltfLoader.load(url, (gltf) => {
					currentModel = gltf.scene;
					
					// Center and scale the model
					const box = new THREE.Box3().setFromObject(currentModel);
					const center = box.getCenter(new THREE.Vector3());
					const size = box.getSize(new THREE.Vector3());
					const maxDim = Math.max(size.x, size.y, size.z);
					const scale = 6 / maxDim;
					
					currentModel.scale.setScalar(scale);
					currentModel.position.sub(center.multiplyScalar(scale));
					currentModel.position.y = 2;
					
					// Add emissive glow
					currentModel.traverse((child) => {
						if (child.isMesh) {
							child.castShadow = true;
							child.receiveShadow = true;
							if (child.material) {
								child.material.emissive = new THREE.Color(0xa78bfa);
								child.material.emissiveIntensity = 0.05;
							}
						}
					});
					
					modelGroup.add(currentModel);
					
					// Update model info
					let totalVertices = 0;
					let totalTriangles = 0;
					let materialCount = 0;
					
					currentModel.traverse((child) => {
						if (child.isMesh && child.geometry) {
							totalVertices += child.geometry.attributes.position?.count || 0;
							totalTriangles += child.geometry.index ? child.geometry.index.count / 3 : 0;
							materialCount++;
						}
					});
					
					if (vertexCountEl) vertexCountEl.textContent = totalVertices.toLocaleString();
					if (triangleCountEl) triangleCountEl.textContent = Math.floor(totalTriangles).toLocaleString();
					if (materialCountEl) materialCountEl.textContent = materialCount.toString();
					
					// Show model info panel
					modelInfo.classList.remove('hidden');
					updatePipelineState(3);
					hideStatus();
					
				}, undefined, (error) => {
					console.error('Error loading model:', error);
					showStatus('Error loading model');
					setTimeout(hideStatus, 3000);
				});
			}
			
			// Generate button handler - Full pipeline
			btnGenerate?.addEventListener('click', async () => {
				const prompt = promptInput?.value || 'a futuristic robot';
				
				if (!prompt.trim()) {
					showStatus('Please enter a prompt');
					setTimeout(hideStatus, 2000);
					return;
				}
				
				// Stage 1: Generating image
				updatePipelineState(1);
				showStatus('Generating image from text...');
				
				try {
					// Stage 2: Generate image with theme analysis
					const result = await generateImage(prompt);
					currentImageUrl = result.imageUrl;
					generatedImage.src = result.imageUrl;
					generatedImage.classList.remove('hidden');
					imagePlaceholder.classList.add('hidden');
					updatePipelineState(2);
					
					// Show enhanced prompt if available
					if (result.enhancedPrompt && !result.fallback) {
						console.log('Enhanced prompt:', result.enhancedPrompt);
						if (result.theme) {
							console.log('Detected theme:', result.theme.primary_theme);
						}
					}
					
					showStatus('Image generated! Ready for 3D conversion.');
					setTimeout(hideStatus, 3000);
					
				} catch (error) {
					showStatus(`Error: ${error.message}`);
					setTimeout(hideStatus, 3000);
				}
			});
			
			// Generate 3D button
			btnGenerate3d?.addEventListener('click', async () => {
				if (!currentImageUrl) {
					showStatus('No image available for 3D conversion');
					setTimeout(hideStatus, 2000);
					return;
				}
				
				showStatus('Generating 3D model via HuggingFace TripoSR... (this may take 30-60s)');
				
				try {
					const modelUrl = await generateModel3D(currentImageUrl);
					loadModel(modelUrl);
					updatePipelineState(3);
				} catch (error) {
					showStatus(`3D Error: ${error.message}`);
					setTimeout(hideStatus, 4000);
				}
			});
			
			// Demo button handler
			btnDemo?.addEventListener('click', () => {
				const demoModels = [
					'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb',
					'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Fox/glTF-Binary/Fox.glb',
					'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BrainStem/glTF-Binary/BrainStem.glb',
					'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb',
					'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
				];
				
				const randomModel = demoModels[Math.floor(Math.random() * demoModels.length)];
				loadModel(randomModel);
			});
			
			// Double-click to reset camera
			renderer.domElement.addEventListener('dblclick', () => {
				camera.position.set(0, 5, 15);
				camera.lookAt(0, 2, 0);
				controls.target.set(0, 2, 0);
				controls.update();
			});
			
			// Animation loop
			const clock = new THREE.Clock();
			
			function animate() {
				requestAnimationFrame(animate);
				
				const time = clock.getElapsedTime();
				
				// Rotate model slowly
				if (currentModel) {
					currentModel.rotation.y = time * 0.2;
				}
				
				// Animate dynamic lights if they have intensity > 0
				if (dynamicLights[0].intensity > 0) {
					dynamicLights[0].position.x = Math.sin(time * 0.5) * 8;
					dynamicLights[0].position.z = Math.cos(time * 0.5) * 8;
				}
				if (dynamicLights[1].intensity > 0) {
					dynamicLights[1].position.x = Math.sin(time * 0.5 + Math.PI) * 8;
					dynamicLights[1].position.z = Math.cos(time * 0.5 + Math.PI) * 8;
				}
				if (dynamicLights[2].intensity > 0) {
					dynamicLights[2].intensity = dynamicLights[2].intensity * (1 + Math.sin(time * 2) * 0.1);
				}
				
				controls.update();
				renderer.render(scene, camera);
			}
			
			// Handle resize
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
			
			// Hide loading, show UI
			setTimeout(() => {
				loading.style.opacity = '0';
				setTimeout(() => {
					loading.style.display = 'none';
				}, 300);
				uiOverlay.style.opacity = '1';
			}, 500);
			
			animate();
		}
		
		// Start when page loads
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', init);
		} else {
			init();
		}
	</script>
</Layout>
